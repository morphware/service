// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.4;

import './IERC20.sol';
import './SafeMath.sol';
import './VickreyAuction.sol';

///@dev This implementation describes the following scenario,
///     for demonstration purposes:
///
///          `endUser` --> `workerNode`
///          `endUser` <-- `workerNode`
///
///      There are no `reviewerNodes`, in this use-case.

/*
    Early stopping    - Vickrey Auction, using the SimpleAuction contract?
    Active monitoring - Micropayment channel?
*/

/* 
    `rewardSchedule` is currently thought to be either a:
    - continuous reward (TBA: worker is rewarded essentially for descending the gradient)
    - variable reward (Early Stopping; kind-of a Boolean pay-off structure: as workers will
        only be rewarded if they have reached a threshold-level of accuracy)
    - fixed interval reward (Active Monitoring)
    - fixed ratio reward (for validators(?); as they will verify a certain number of models
        over a period of time: even if the selection process for them is pseudo-random?)
    ...encoded as a `string` or a series of `bytes`
*/

/* 
    Implement a form of a reputation score that basically updates how off 
    a given `endUser`'s estimation is of their workload's training time 
*/

contract JobFactory {

    // TODO Add `SafeMath8` to `SafeMath.sol`
    //      and the for rest of them
    /* 
    using SafeMath8 for uint8;
    using SafeMath16 for uint16;
    using SafeMath32 for uint32;
    using SafeMath64 for uint64;
    using SafeMath for uint256;
    */

    event JobDescriptionPosted(
        address jobPoster,
        uint id,
        address auctionContract,
        uint16 estimatedTrainingTime,
        uint32 trainingDatasetSize,
        uint workerReward
    );

    event UntrainedModelAndTrainingDatasetShared(
        address workerNode,
        bytes32 untrainedModelMagnetLink,
        bytes32 trainingDatasetMagnetLink,
        uint64 targetErrorRate
    );

    event TrainedModelDescriptionPosted(
        uint32 testingDatasetSize,
        uint reviewerReward
    );

    event TrainedModelAndTestingDatasetShared(
        bytes32 trainedModelMagnetLink,
        bytes32 testingDatasetMagnetLink
    );

    enum Status {
        PostedJobDescription,
        SharedUntrainedModelAndTrainingDataset,
        PostedTrainedModelDescription,
        SharedTrainedModelAndTestingDataset,
    };

    struct Job {
        Status status,
        uint64 targetErrorRate,
        address workerNode,
    };

    mapping (address => Job[]) public jobs;

    IERC20 public token;

    /// @dev    This is being called by `endUser`
    /// @notice `address(0)` is being passed to `Job` as a placeholder
    function postJobDescription(
        IERC20 _token,
        uint16 _estimatedTrainingTime,
        uint32 _trainingDatasetSize,
        uint64 _targetErrorRate,
        uint _minimumPayout,
        uint _biddingTimeSpan,
        uint _revealTimeSpan,
        uint _workerReward
    ) public {
        vickreyAuction = new VickreyAuction(
            _token,
            _minimumPayout,
            _biddingTimeSpan,
            _revealTimeSpan,
            _workerReward,
            msg.sender);
        uint id = jobs[msg.sender].push(Job(
            PostedJobDescription,
            _targetErrorRate,
            address(0),
        )).sub(1);
        emit JobDescriptionPosted(
            msg.sender,
            id,
            vickreyAuction.address,
            _estimatedTrainingTime,
            _trainingDatasetSize,
            _workerReward
        );
    } 

    /// @dev    This is being called by `endUser`
    ///
    /// @notice The Jupyter notebook and the training dataset have
    ///         been encrypted with the `highestBidders`'s pub. key
    function shareUntrainedModelAndTrainingDataset(
        uint _id,
        bytes32 _untrainedModelMagnetLink,
        bytes32 _trainingDatasetMagnetLink
    ) public {
        require(vickreyAuction.ended,'VickreyAuction has not ended');
        require(jobs[msg.sender][_id].status == PostedJobDescription,'Job has not been posted');
        jobs[msg.sender][_id].status = SharedUntrainedModelAndTrainingDataset;
        jobs[msg.sender][_id].workerNode = vickreyAuction.highestBidder;
        emit UntrainedModelAndTrainingDatasetShared(
            jobs[msg.sender][_id].workerNode,
            _untrainedModelMagnetLink,
            _trainingDatasetMagnetLink,
            jobs[msg.sender][_id].targetErrorRate
        );
    }

    /// @dev  This is being called by `workerNode`
    ///
    /// @notice The `testingRumtime` and `testingDataset` cannot
    ///         be encrypted without a `validator`'s pub. key
    //function shareTrainedModel(
    /* function postTrainedModelDescription(
        address _jobPoster,
        uint _id,
        uint _testingDatasetSize,
        uint64 _performance
    ) public {
        require(msg.sender == jobs[_jobPoster][_id].workerNode,'msg.sender must equal workerNode');
        require(jobs[_jobPoster][_id].status == PostedJobDescription,'Job has not been started');
        require(jobs[_jobPoster][_id].targetErrorRate >= _performance,'targetErrorRate must be greater or equal to performance');

        jobs[_jobPoster][_id].status = PostedTrainedModelDescription; */
        
        /*
         * `Ballot.sol`???
         * Get the `validatorNodes` to download the file and to sign it or something,
         * to demostrate that they have skin-in-the-game?
        */

        // TODO `require` that the `validatorNodes` 
        //      are not `endUser` or the `workerNode`


        // FIXME Implement the randomDna thing with `mod`,
        //       to select parts of the testing set

        
        // FIXME `reviewerReward` is not defined!
    /*    emit TrainedModelDescriptionPosted(
            _testingDatasetSize,
            reviewerReward
        );
    } */

    function shareTrainedModelAndTestingDataset(
        bytes32 _trainedModelMagnetLink,
        bytes32 _testingDatasetMagnetLink
    ) public {
        


        emit TrainedModelandTestingDatasetShared(
            bytes32 _trainedModelMagnetLink,
            bytes32 _testingDatasetMagnetLink
        );

    }

    //bytes32 _trainedModelMagnetLink,
    //_trainedModelMagnetLink,

    function reviewWork(
        bytes32 _trainedModelMagnetLink,
        bytes32 _testingDatasetMagnetLink
    ) public {
        require(vickreyAuction.ended,'VickreyAuction has not ended');
        require(jobs[msg.sender][id].status == Submitted,'Job has not been started');








        jobs[msg.sender][id].status = Checked;

        emit WorkReviewed(
            // TODO
        )
        // TODO  Reward the validators as well
        auction.payout();
    }
}
